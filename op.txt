('ASSIGN', [['identifier', '=', 'EXPRESSION', ';']])
('ASSIGN_ST', [['ASSIGN', 'ST'], ['ASSIGN']])
('COND', [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']])
('DECL', [['type', 'identifier', ';']])
('DECL_ST', [['DECL', 'ST'], ['DECL']])
('DEFN', [['type', 'ASSIGN']])
('DEFN_ST', [['DEFN', 'ST'], ['DEFN']])
('E', [['T', "E'"], ['T']])
("E'", [['+', 'T', "E'"], ['+', 'T'], ['-', 'T', "E'"], ['-', 'T']])
('EXPRESSION', [['E']])
('EXPRESSION1', [['EXPRESSION']])
('EXPRESSION2', [['EXPRESSION']])
('F', [['^', 'G', 'F'], ['G']])
('FOR_LOOP', [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']])
('FOR_LOOP_ST', [['FOR_LOOP', 'ST'], ['FOR_LOOP']])
('G', [['(', 'E', ')'], ['identifier'], ['number']])
('IF_COND', [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']])
('IF_COND_ST', [['IF_COND', 'ST'], ['IF_COND']])
('INCREMENT', [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']])
('I_ASSIGN', [['identifier', '=', 'EXPRESSION']])
('I_COND', [['EXPRESSION1', 'relational_operator', 'EXPRESSION2']])
('OP_ELSE', [['else', '{', 'STATEMENT', '}']])
('PROG', [['STATEMENT', 'eof']])
('ST', [['STATEMENT_ST']])
('STATEMENT', [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']])
('STATEMENT_ST', [['STATEMENT', ';', 'ST'], ['STATEMENT']])
('T', [['F', "T'"], ['F']])
("T'", [['*', 'F', "T'"], ['*', 'F'], ['/', 'F', "T'"], ['/', 'F']])


[('int', 'type'), ('x', 'identifier'), (';', 'punctuation')]




TREE
PROG 
in match rule with  PROG : [['STATEMENT', 'eof']]
in rule  ['STATEMENT', 'eof']  with  int
TREE
PROG [STATEMENT eof ] 
SYMBOL  STATEMENT
in symbol STATEMENT 		(in rule  ['STATEMENT', 'eof'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  int
TREE
STATEMENT [FOR_LOOP_ST ] 
SYMBOL  FOR_LOOP_ST
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  int
TREE
FOR_LOOP_ST [FOR_LOOP ST ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  int
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else int for
5. unmatched for int
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP int int ['FOR_LOOP', 'ST']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  int
TREE
FOR_LOOP_ST [FOR_LOOP ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  int
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else int for
5. unmatched for int
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP int int ['FOR_LOOP']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST int int ['FOR_LOOP_ST']
TREE
STATEMENT 
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  int
TREE
STATEMENT [IF_COND_ST ] 
SYMBOL  IF_COND_ST
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  int
TREE
IF_COND_ST [IF_COND ST ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  int
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else int if
5. unmatched if int
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  int
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else int if
5. unmatched if int
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND int int ['IF_COND', 'ST']
TREE
IF_COND_ST 
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  int
TREE
IF_COND_ST [IF_COND ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  int
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else int if
5. unmatched if int
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  int
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else int if
5. unmatched if int
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND int int ['IF_COND']
TREE
IF_COND_ST 
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST int int ['IF_COND_ST']
TREE
STATEMENT 
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  int
TREE
STATEMENT [DEFN_ST ] 
SYMBOL  DEFN_ST
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  int
TREE
DEFN_ST [DEFN ST ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  int
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token int type type
2.SYMBOL in RULE type ['type', 'ASSIGN']
matched
2. temp store x x
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['type', 'ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  x
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token x identifier identifier
2.SYMBOL in RULE identifier ['identifier', '=', 'EXPRESSION', ';']
matched
2. temp store ; ;
SYMBOL  =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; =
5. unmatched = ;
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN x ; ['type', 'ASSIGN']
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN int ; ['DEFN', 'ST']
TREE
DEFN_ST 
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  int
TREE
DEFN_ST [DEFN ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  int
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token int type type
2.SYMBOL in RULE type ['type', 'ASSIGN']
matched
2. temp store x x
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['type', 'ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  x
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token x identifier identifier
2.SYMBOL in RULE identifier ['identifier', '=', 'EXPRESSION', ';']
matched
2. temp store ; ;
SYMBOL  =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; =
5. unmatched = ;
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN x ; ['type', 'ASSIGN']
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN int ; ['DEFN']
TREE
DEFN_ST 
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST int ; ['DEFN_ST']
TREE
STATEMENT 
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  int
TREE
STATEMENT [ASSIGN_ST ] 
SYMBOL  ASSIGN_ST
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  int
TREE
ASSIGN_ST [ASSIGN ST ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  int
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token int type identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN int ; ['ASSIGN', 'ST']
TREE
ASSIGN_ST 
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  int
TREE
ASSIGN_ST [ASSIGN ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  int
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token int type identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN int ; ['ASSIGN']
TREE
ASSIGN_ST 
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST int ; ['ASSIGN_ST']
TREE
STATEMENT 
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  int
TREE
STATEMENT [DECL_ST ] 
SYMBOL  DECL_ST
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  int
TREE
DECL_ST [DECL ST ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  int
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token int type type
2.SYMBOL in RULE type ['type', 'identifier', ';']
matched
2. temp store x x
SYMBOL  identifier
in symbol identifier 		(in rule  ['type', 'identifier', ';'] )
is token
in match token x identifier identifier
2.SYMBOL in RULE identifier ['type', 'identifier', ';']
matched
2. temp store ; ;
SYMBOL  ;
in symbol ; 		(in rule  ['type', 'identifier', ';'] )
else ; ;
matched
here we are ['type', 'identifier', ';'] [['type', 'identifier', ';']] 0
1.SYMBOL in RULE DECL ['DECL', 'ST']
1. temp store eof eof
SYMBOL  ST
in symbol ST 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  ST : [['STATEMENT_ST']]
in rule  ['STATEMENT_ST']  with  eof
TREE
ST [STATEMENT_ST ] 
SYMBOL  STATEMENT_ST
in symbol STATEMENT_ST 		(in rule  ['STATEMENT_ST'] )
in producer
in match rule with  STATEMENT_ST : [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT', ';', 'ST']  with  eof
TREE
STATEMENT_ST [STATEMENT ; ST ] 
SYMBOL  STATEMENT
in symbol STATEMENT 		(in rule  ['STATEMENT', ';', 'ST'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  eof
TREE
STATEMENT [FOR_LOOP_ST ] 
SYMBOL  FOR_LOOP_ST
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  eof
TREE
FOR_LOOP_ST [FOR_LOOP ST ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP', 'ST']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  eof
TREE
FOR_LOOP_ST [FOR_LOOP ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST eof eof ['FOR_LOOP_ST']
TREE
STATEMENT 
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  eof
TREE
STATEMENT [IF_COND_ST ] 
SYMBOL  IF_COND_ST
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  eof
TREE
IF_COND_ST [IF_COND ST ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND', 'ST']
TREE
IF_COND_ST 
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  eof
TREE
IF_COND_ST [IF_COND ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND']
TREE
IF_COND_ST 
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST eof eof ['IF_COND_ST']
TREE
STATEMENT 
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  eof
TREE
STATEMENT [DEFN_ST ] 
SYMBOL  DEFN_ST
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  eof
TREE
DEFN_ST [DEFN ST ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  eof
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token eof eof type
4. unmatched token
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN eof eof ['DEFN', 'ST']
TREE
DEFN_ST 
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  eof
TREE
DEFN_ST [DEFN ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  eof
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token eof eof type
4. unmatched token
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN eof eof ['DEFN']
TREE
DEFN_ST 
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST eof eof ['DEFN_ST']
TREE
STATEMENT 
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  eof
TREE
STATEMENT [ASSIGN_ST ] 
SYMBOL  ASSIGN_ST
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  eof
TREE
ASSIGN_ST [ASSIGN ST ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN', 'ST']
TREE
ASSIGN_ST 
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  eof
TREE
ASSIGN_ST [ASSIGN ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN']
TREE
ASSIGN_ST 
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST eof eof ['ASSIGN_ST']
TREE
STATEMENT 
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  eof
TREE
STATEMENT [DECL_ST ] 
SYMBOL  DECL_ST
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  eof
TREE
DECL_ST [DECL ST ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
TREE
DECL 
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL', 'ST']
TREE
DECL_ST 
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  eof
TREE
DECL_ST [DECL ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
TREE
DECL 
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL']
TREE
DECL_ST 
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST eof eof ['DECL_ST']
TREE
STATEMENT 
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT eof eof ['STATEMENT', ';', 'ST']
TREE
STATEMENT_ST 
returned false  ['STATEMENT', ';', 'ST'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT']  with  eof
TREE
STATEMENT_ST [STATEMENT ] 
SYMBOL  STATEMENT
in symbol STATEMENT 		(in rule  ['STATEMENT'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  eof
TREE
STATEMENT [FOR_LOOP_ST ] 
SYMBOL  FOR_LOOP_ST
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  eof
TREE
FOR_LOOP_ST [FOR_LOOP ST ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP', 'ST']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  eof
TREE
FOR_LOOP_ST [FOR_LOOP ] 
SYMBOL  FOR_LOOP
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP [for ( ASSIGN COND INCREMENT ) { STATEMENT } ] 
SYMBOL  for
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
TREE
FOR_LOOP 
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP']
TREE
FOR_LOOP_ST 
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST eof eof ['FOR_LOOP_ST']
TREE
STATEMENT 
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  eof
TREE
STATEMENT [IF_COND_ST ] 
SYMBOL  IF_COND_ST
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  eof
TREE
IF_COND_ST [IF_COND ST ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND', 'ST']
TREE
IF_COND_ST 
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  eof
TREE
IF_COND_ST [IF_COND ] 
SYMBOL  IF_COND
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT ; } OP_ELSE ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
IF_COND [if ( COND ) { STATEMENT } ] 
SYMBOL  if
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
TREE
IF_COND 
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND']
TREE
IF_COND_ST 
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST eof eof ['IF_COND_ST']
TREE
STATEMENT 
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  eof
TREE
STATEMENT [DEFN_ST ] 
SYMBOL  DEFN_ST
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  eof
TREE
DEFN_ST [DEFN ST ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  eof
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token eof eof type
4. unmatched token
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN eof eof ['DEFN', 'ST']
TREE
DEFN_ST 
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  eof
TREE
DEFN_ST [DEFN ] 
SYMBOL  DEFN
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'ASSIGN']]
in rule  ['type', 'ASSIGN']  with  eof
TREE
DEFN [type ASSIGN ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'ASSIGN'] )
is token
in match token eof eof type
4. unmatched token
TREE
DEFN 
returned false  ['type', 'ASSIGN'] [['type', 'ASSIGN']]
2. unmatched DEFN eof eof ['DEFN']
TREE
DEFN_ST 
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST eof eof ['DEFN_ST']
TREE
STATEMENT 
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  eof
TREE
STATEMENT [ASSIGN_ST ] 
SYMBOL  ASSIGN_ST
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  eof
TREE
ASSIGN_ST [ASSIGN ST ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN', 'ST']
TREE
ASSIGN_ST 
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  eof
TREE
ASSIGN_ST [ASSIGN ] 
SYMBOL  ASSIGN
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
ASSIGN [identifier = EXPRESSION ; ] 
SYMBOL  identifier
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
TREE
ASSIGN 
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN']
TREE
ASSIGN_ST 
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST eof eof ['ASSIGN_ST']
TREE
STATEMENT 
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  eof
TREE
STATEMENT [DECL_ST ] 
SYMBOL  DECL_ST
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  eof
TREE
DECL_ST [DECL ST ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
TREE
DECL 
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL', 'ST']
TREE
DECL_ST 
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  eof
TREE
DECL_ST [DECL ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
TREE
DECL 
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL']
TREE
DECL_ST 
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST eof eof ['DECL_ST']
TREE
STATEMENT 
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT eof eof ['STATEMENT']
TREE
STATEMENT_ST 
returned false  ['STATEMENT'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
2. unmatched STATEMENT_ST eof eof ['STATEMENT_ST']
TREE
ST 
returned false  ['STATEMENT_ST'] [['STATEMENT_ST']]
2. unmatched ST eof eof ['DECL', 'ST']
TREE
DECL_ST 
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  int
TREE
DECL_ST [DECL ] 
SYMBOL  DECL
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  int
TREE
DECL [type identifier ; ] 
SYMBOL  type
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token int type type
2.SYMBOL in RULE type ['type', 'identifier', ';']
matched
2. temp store x x
SYMBOL  identifier
in symbol identifier 		(in rule  ['type', 'identifier', ';'] )
is token
in match token x identifier identifier
2.SYMBOL in RULE identifier ['type', 'identifier', ';']
matched
2. temp store ; ;
SYMBOL  ;
in symbol ; 		(in rule  ['type', 'identifier', ';'] )
else ; ;
matched
here we are ['type', 'identifier', ';'] [['type', 'identifier', ';']] 0
1.SYMBOL in RULE DECL ['DECL']
1. temp store int eof
here we are ['DECL'] [['DECL', 'ST'], ['DECL']] 1
1.SYMBOL in RULE DECL_ST ['DECL_ST']
1. temp store int eof
here we are ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']] 4
1.SYMBOL in RULE STATEMENT ['STATEMENT', 'eof']
1. temp store eof eof
SYMBOL  eof
in symbol eof 		(in rule  ['STATEMENT', 'eof'] )
else eof eof
done!
here we are ['STATEMENT', 'eof'] [['STATEMENT', 'eof']] 0
VALID int eof
TREE
PROG [STATEMENT [DECL_ST [DECL [type identifier ; ] ] ] eof ] 
