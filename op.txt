('ASSIGN', [['identifier', '=', 'EXPRESSION', ';']])
('ASSIGN_ST', [['ASSIGN', 'ST'], ['ASSIGN']])
('COND', [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']])
('DECL', [['type', 'identifier', ';']])
('DECL_ST', [['DECL', 'ST'], ['DECL']])
('DEFN', [['type', 'identifier', '=', 'EXPRESSION', ';']])
('DEFN_ST', [['DEFN', 'ST'], ['DEFN']])
('E', [['T', "E'"], ['T']])
("E'", [['+', 'T', "E'"], ['-', 'T', "E'"]])
('EXPRESSION', [['E']])
('EXPRESSION1', [['EXPRESSION']])
('EXPRESSION2', [['EXPRESSION']])
('F', [['G', '^', 'F'], ['G']])
('FOR_LOOP', [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']])
('FOR_LOOP_ST', [['FOR_LOOP', 'ST'], ['FOR_LOOP']])
('G', [['(', 'E', ')'], ['identifier'], ['number']])
('IF_COND', [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']])
('IF_COND_ST', [['IF_COND', 'ST'], ['IF_COND']])
('INCREMENT', [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']])
('I_ASSIGN', [['identifier', '=', 'EXPRESSION']])
('OP_ELSE', [['else', '{', 'STATEMENT', '}']])
('PROG', [['STATEMENT', 'eof']])
('ST', [['STATEMENT_ST']])
('STATEMENT', [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']])
('STATEMENT_ST', [['STATEMENT', ';', 'ST'], ['STATEMENT']])
('T', [['F', "T'"], ['F']])
("T'", [['*', 'F', "T'"], ['/', 'F', "T'"]])


[('for', 'keyword'), ('(', 'punctuation'), ('i', 'identifier'), ('=', 'assignment_operator'), ('0', 'number'), (';', 'punctuation'), ('j', 'identifier'), ('<', 'relational_operator'), ('10', 'number'), (';', 'punctuation'), ('k', 'identifier'), ('=', 'assignment_operator'), ('5', 'number'), (')', 'punctuation'), ('{', 'punctuation'), ('l', 'identifier'), ('=', 'assignment_operator'), ('5', 'number'), (';', 'punctuation'), ('}', 'punctuation')]




TREE
PROG 
STACK  ['PROG']
in match rule with  PROG : [['STATEMENT', 'eof']]
in rule  ['STATEMENT', 'eof']  with  for
TREE
PROG (STATEMENT eof ) 
STACK  ['PROG', ['STATEMENT', 'eof']]
in symbol STATEMENT 		(in rule  ['STATEMENT', 'eof'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  for
TREE
STATEMENT (FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  for
TREE
FOR_LOOP_ST (FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  for
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else for for
matched
in symbol ( 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else ( (
matched
in symbol ASSIGN 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  i
TREE
ASSIGN (identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token i identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  0
TREE
EXPRESSION (E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  0
TREE
E (T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  0
TREE
T (F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ) ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ) ^ F G ) T' (* F T' / F T' ) F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ) ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 0 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  0
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F ) E' (+ T E' - T E' ) T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 0 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 0 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 0 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store j j
in symbol COND 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  COND : [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']]
in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']  with  j
TREE
COND (EXPRESSION1 relational_operator EXPRESSION2 ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']]
in symbol EXPRESSION1 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
in producer
in match rule with  EXPRESSION1 : [['EXPRESSION']]
in rule  ['EXPRESSION']  with  j
TREE
EXPRESSION1 (EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION']]
in symbol EXPRESSION 		(in rule  ['EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  j
TREE
EXPRESSION (E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  j
TREE
E (T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  j
TREE
T (F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ) ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store < <
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  <
TREE
T' (* F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else < *
5. unmatched * <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else < /
5. unmatched / <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' < < ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ) ^ F G ) T' (* F T' / F T' ) F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ) ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store j <
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store < <
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  <
TREE
E' (+ T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else < +
5. unmatched + <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  <
TREE
E' (+ T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else < -
5. unmatched - <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' < < ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  j
TREE
E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G ) T' (* F T' / F T' ) F ) E' (+ T E' - T E' ) T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G ) T' (* F T' / F T' ) F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store < <
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else < *
5. unmatched * <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else < /
5. unmatched / <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' < < ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store j <
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store j <
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store j <
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['EXPRESSION']
1. temp store j <
here we are ['EXPRESSION'] [['EXPRESSION']] 0
1.SYMBOL in RULE EXPRESSION1 ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']
1. temp store < <
in symbol relational_operator 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
is token
in match token < relational_operator relational_operator
matched
2. temp store 10 10
in symbol EXPRESSION2 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
in producer
in match rule with  EXPRESSION2 : [['EXPRESSION']]
in rule  ['EXPRESSION']  with  10
TREE
EXPRESSION2 (EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION']]
in symbol EXPRESSION 		(in rule  ['EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  10
TREE
EXPRESSION (E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  10
TREE
E (T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  10
TREE
T (F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ) ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ) ^ F G ) T' (* F T' / F T' ) F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ) ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 10 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  10
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F ) E' (+ T E' - T E' ) T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 10 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 10 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 10 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['EXPRESSION']
1. temp store 10 ;
here we are ['EXPRESSION'] [['EXPRESSION']] 0
1.SYMBOL in RULE EXPRESSION2 ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
else ; ;
matched
here we are ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']] 0
1.SYMBOL in RULE COND ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store k k
in symbol INCREMENT 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  INCREMENT : [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']]
in rule  ['I_ASSIGN']  with  k
TREE
INCREMENT (I_ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN']]
in symbol I_ASSIGN 		(in rule  ['I_ASSIGN'] )
in producer
in match rule with  I_ASSIGN : [['identifier', '=', 'EXPRESSION']]
in rule  ['identifier', '=', 'EXPRESSION']  with  k
TREE
I_ASSIGN (identifier = EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION'] )
is token
in match token k identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
EXPRESSION (E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ) ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ) )
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  )
TREE
T' (* F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ) *
5. unmatched * )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ) /
5. unmatched / )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ) ) ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ) ^ F G ) T' (* F T' / F T' ) F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ) ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 )
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ) )
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  )
TREE
E' (+ T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ) +
5. unmatched + )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  )
TREE
E' (+ T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ) -
5. unmatched - )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ) ) ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F ) E' (+ T E' - T E' ) T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ) )
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ) *
5. unmatched * )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ) /
5. unmatched / )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ) ) ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 )
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 )
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 )
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION']
1. temp store 5 )
here we are ['identifier', '=', 'EXPRESSION'] [['identifier', '=', 'EXPRESSION']] 0
1.SYMBOL in RULE I_ASSIGN ['I_ASSIGN']
1. temp store k )
here we are ['I_ASSIGN'] [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']] 0
1.SYMBOL in RULE INCREMENT ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store ) )
in symbol ) 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else ) )
matched
in symbol { 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else { {
matched
in symbol STATEMENT 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else l for
5. unmatched for l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP l l ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else l for
5. unmatched for l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP l l ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST l l ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND l l ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND l l ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST l l ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN l l ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN l l ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST l l ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
ASSIGN (E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ) ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ) ^ F G ) T' (* F T' / F T' ) F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ) ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F ) E' (+ T E' - T E' ) T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G ) T' (* F T' / F T' ) F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['ASSIGN', 'ST']
1. temp store } }
in symbol ST 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ST : [['STATEMENT_ST']]
in rule  ['STATEMENT_ST']  with  }
TREE
ST (STATEMENT_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
in symbol STATEMENT_ST 		(in rule  ['STATEMENT_ST'] )
in producer
in match rule with  STATEMENT_ST : [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT', ';', 'ST']  with  }
TREE
STATEMENT_ST (STATEMENT ; ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
in symbol STATEMENT 		(in rule  ['STATEMENT', ';', 'ST'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST } } ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST } } ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST } } ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST } } ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST } } ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT } } ['STATEMENT', ';', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT', ';', 'ST'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT']  with  }
TREE
STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
in symbol STATEMENT 		(in rule  ['STATEMENT'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST } } ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST } } ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST } } ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST } } ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST } } ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT } } ['STATEMENT']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
2. unmatched STATEMENT_ST } } ['STATEMENT_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['STATEMENT_ST'] [['STATEMENT_ST']]
2. unmatched ST } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['ASSIGN']
1. temp store l }
here we are ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']] 1
1.SYMBOL in RULE ASSIGN_ST ['ASSIGN_ST']
1. temp store l }
here we are ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']] 3
1.SYMBOL in RULE STATEMENT ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store } }
in symbol } 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } }
matched
here we are ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']] 0
1.SYMBOL in RULE FOR_LOOP ['FOR_LOOP', 'ST']
1. temp store eof eof
in symbol ST 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  ST : [['STATEMENT_ST']]
in rule  ['STATEMENT_ST']  with  eof
TREE
ST (STATEMENT_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
in symbol STATEMENT_ST 		(in rule  ['STATEMENT_ST'] )
in producer
in match rule with  STATEMENT_ST : [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT', ';', 'ST']  with  eof
TREE
STATEMENT_ST (STATEMENT ; ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
in symbol STATEMENT 		(in rule  ['STATEMENT', ';', 'ST'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST eof eof ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP ) IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST eof eof ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN eof eof ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN eof eof ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST eof eof ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST eof eof ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST eof eof ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT eof eof ['STATEMENT', ';', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT', ';', 'ST'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT']  with  eof
TREE
STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
in symbol STATEMENT 		(in rule  ['STATEMENT'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else eof for
5. unmatched for eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP eof eof ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST eof eof ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else eof if
5. unmatched if eof
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND eof eof ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST eof eof ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN eof eof ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN eof eof ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST eof eof ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token eof eof identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN eof eof ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST eof eof ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  eof
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  eof
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  eof
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token eof eof type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL eof eof ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST eof eof ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT eof eof ['STATEMENT']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
2. unmatched STATEMENT_ST eof eof ['STATEMENT_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['STATEMENT_ST'] [['STATEMENT_ST']]
2. unmatched ST eof eof ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  for
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ; ) COND (EXPRESSION1 (EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) relational_operator EXPRESSION2 (EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) ; ) INCREMENT (I_ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) ) ) { STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST ) } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  for
TREE
FOR_LOOP (for ( ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ; ) COND (EXPRESSION1 (EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) relational_operator EXPRESSION2 (EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) ; ) INCREMENT (I_ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) ) ) { STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST ) } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else for for
matched
in symbol ( 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else ( (
matched
in symbol ASSIGN 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  i
TREE
ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token i identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  0
TREE
EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  0
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 0 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  0
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  0
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  0
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 0 (
5. unmatched ( 0
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 0 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  0
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 0 number number
matched
2. temp store 0 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 0 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 0 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 0 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 0 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store j j
in symbol COND 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  COND : [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']]
in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']  with  j
TREE
COND (EXPRESSION1 (EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) relational_operator EXPRESSION2 (EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) ; EXPRESSION1 relational_operator EXPRESSION2 ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']]
in symbol EXPRESSION1 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
in producer
in match rule with  EXPRESSION1 : [['EXPRESSION']]
in rule  ['EXPRESSION']  with  j
TREE
EXPRESSION1 (EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION']]
in symbol EXPRESSION 		(in rule  ['EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  j
TREE
EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  j
TREE
E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store < <
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else < *
5. unmatched * <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else < /
5. unmatched / <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' < < ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store j <
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store < <
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  <
TREE
E' (+ T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else < +
5. unmatched + <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  <
TREE
E' (+ T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else < -
5. unmatched - <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' < < ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  j
TREE
E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store < <
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else < *
5. unmatched * <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  <
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else < /
5. unmatched / <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' < < ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  j
TREE
T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store < <
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else < ^
5. unmatched ^ <
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  j
TREE
F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else j (
5. unmatched ( j
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  j
TREE
G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token j identifier identifier
matched
2. temp store j <
here we are ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']] 1
1.SYMBOL in RULE G ['G']
1. temp store j <
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store j <
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store j <
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store j <
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['EXPRESSION']
1. temp store j <
here we are ['EXPRESSION'] [['EXPRESSION']] 0
1.SYMBOL in RULE EXPRESSION1 ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']
1. temp store < <
in symbol relational_operator 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
is token
in match token < relational_operator relational_operator
matched
2. temp store 10 10
in symbol EXPRESSION2 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
in producer
in match rule with  EXPRESSION2 : [['EXPRESSION']]
in rule  ['EXPRESSION']  with  10
TREE
EXPRESSION2 (EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION']]
in symbol EXPRESSION 		(in rule  ['EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  10
TREE
EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  10
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 10 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  10
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  10
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  10
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 10 (
5. unmatched ( 10
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 10 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  10
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 10 number number
matched
2. temp store 10 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 10 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 10 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 10 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 10 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['EXPRESSION']
1. temp store 10 ;
here we are ['EXPRESSION'] [['EXPRESSION']] 0
1.SYMBOL in RULE EXPRESSION2 ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] )
else ; ;
matched
here we are ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'] [['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';']] 0
1.SYMBOL in RULE COND ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store k k
in symbol INCREMENT 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  INCREMENT : [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']]
in rule  ['I_ASSIGN']  with  k
TREE
INCREMENT (I_ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) ) I_ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN']]
in symbol I_ASSIGN 		(in rule  ['I_ASSIGN'] )
in producer
in match rule with  I_ASSIGN : [['identifier', '=', 'EXPRESSION']]
in rule  ['identifier', '=', 'EXPRESSION']  with  k
TREE
I_ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) ) identifier = EXPRESSION ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION'] )
is token
in match token k identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T ) E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F ) E' (+ T E' - T E' ) T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' ) F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ) )
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ) *
5. unmatched * )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ) /
5. unmatched / )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ) ) ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 )
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ) )
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  )
TREE
E' (+ T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ) +
5. unmatched + )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  )
TREE
E' (+ T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ) -
5. unmatched - )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ) ) ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ) )
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ) *
5. unmatched * )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  )
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ) /
5. unmatched / )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ) ) ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ) )
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ) ^
5. unmatched ^ )
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 )
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 )
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 )
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 )
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 )
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION']
1. temp store 5 )
here we are ['identifier', '=', 'EXPRESSION'] [['identifier', '=', 'EXPRESSION']] 0
1.SYMBOL in RULE I_ASSIGN ['I_ASSIGN']
1. temp store k )
here we are ['I_ASSIGN'] [['I_ASSIGN'], ['I_COND'], ['EXPRESSION']] 0
1.SYMBOL in RULE INCREMENT ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store ) )
in symbol ) 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else ) )
matched
in symbol { 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else { {
matched
in symbol STATEMENT 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else l for
5. unmatched for l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP l l ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else l for
5. unmatched for l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP l l ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST l l ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP ) IF_COND_ST DEFN_ST ASSIGN_ST FOR_LOOP_ST IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND l l ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else l if
5. unmatched if l
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND l l ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST l l ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ASSIGN_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN l l ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN l l ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST l l ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  l
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['ASSIGN', 'ST']
1. temp store } }
in symbol ST 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ST : [['STATEMENT_ST']]
in rule  ['STATEMENT_ST']  with  }
TREE
ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) STATEMENT_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
in symbol STATEMENT_ST 		(in rule  ['STATEMENT_ST'] )
in producer
in match rule with  STATEMENT_ST : [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT', ';', 'ST']  with  }
TREE
STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT STATEMENT ; ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
in symbol STATEMENT 		(in rule  ['STATEMENT', ';', 'ST'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST } } ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST } } ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST } } ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST } } ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST } } ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT', ';', 'ST']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT } } ['STATEMENT', ';', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT', ';', 'ST'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
in rule  ['STATEMENT']  with  }
TREE
STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT STATEMENT ; ST STATEMENT ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
in symbol STATEMENT 		(in rule  ['STATEMENT'] )
in producer
in match rule with  STATEMENT : [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['FOR_LOOP_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
in symbol FOR_LOOP_ST 		(in rule  ['FOR_LOOP_ST'] )
in producer
in match rule with  FOR_LOOP_ST : [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP', 'ST'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP', 'ST']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP', 'ST'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
in rule  ['FOR_LOOP']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
in symbol FOR_LOOP 		(in rule  ['FOR_LOOP'] )
in producer
in match rule with  FOR_LOOP : [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
in symbol for 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } for
5. unmatched for }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST'], ['FOR_LOOP']]
returned false  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']]
2. unmatched FOR_LOOP } } ['FOR_LOOP']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['FOR_LOOP_ST']]
returned false  ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']]
2. unmatched FOR_LOOP_ST } } ['FOR_LOOP_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['IF_COND_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
in symbol IF_COND_ST 		(in rule  ['IF_COND_ST'] )
in producer
in match rule with  IF_COND_ST : [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
in symbol IF_COND 		(in rule  ['IF_COND', 'ST'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND', 'ST']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND', 'ST'] [['IF_COND', 'ST'], ['IF_COND']]
in rule  ['IF_COND']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
in symbol IF_COND 		(in rule  ['IF_COND'] )
in producer
in match rule with  IF_COND : [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
in symbol if 		(in rule  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] )
else } if
5. unmatched if }
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST'], ['IF_COND']]
returned false  ['if', '(', 'COND', ')', '{', 'STATEMENT', '}'] [['if', '(', 'COND', ')', '{', 'STATEMENT', ';', '}', 'OP_ELSE'], ['if', '(', 'COND', ')', '{', 'STATEMENT', '}']]
2. unmatched IF_COND } } ['IF_COND']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['IF_COND_ST']]
returned false  ['IF_COND'] [['IF_COND', 'ST'], ['IF_COND']]
2. unmatched IF_COND_ST } } ['IF_COND_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['IF_COND_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DEFN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
in symbol DEFN_ST 		(in rule  ['DEFN_ST'] )
in producer
in match rule with  DEFN_ST : [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
in symbol DEFN 		(in rule  ['DEFN', 'ST'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN', 'ST']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN', 'ST'] [['DEFN', 'ST'], ['DEFN']]
in rule  ['DEFN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
in symbol DEFN 		(in rule  ['DEFN'] )
in producer
in match rule with  DEFN : [['type', 'identifier', '=', 'EXPRESSION', ';']]
in rule  ['type', 'identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN'], ['type', 'identifier', '=', 'EXPRESSION', ';']]
in symbol type 		(in rule  ['type', 'identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST'], ['DEFN']]
returned false  ['type', 'identifier', '=', 'EXPRESSION', ';'] [['type', 'identifier', '=', 'EXPRESSION', ';']]
2. unmatched DEFN } } ['DEFN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DEFN_ST']]
returned false  ['DEFN'] [['DEFN', 'ST'], ['DEFN']]
2. unmatched DEFN_ST } } ['DEFN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DEFN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['ASSIGN_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
in symbol ASSIGN_ST 		(in rule  ['ASSIGN_ST'] )
in producer
in match rule with  ASSIGN_ST : [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
in symbol ASSIGN 		(in rule  ['ASSIGN', 'ST'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN', 'ST']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token } punctuation identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST'], ['ASSIGN']]
returned false  ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']]
2. unmatched ASSIGN } } ['ASSIGN']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['ASSIGN_ST']]
returned false  ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']]
2. unmatched ASSIGN_ST } } ['ASSIGN_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
in rule  ['DECL_ST']  with  }
TREE
STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
in symbol DECL_ST 		(in rule  ['DECL_ST'] )
in producer
in match rule with  DECL_ST : [['DECL', 'ST'], ['DECL']]
in rule  ['DECL', 'ST']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
in symbol DECL 		(in rule  ['DECL', 'ST'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL', 'ST']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL', 'ST'] [['DECL', 'ST'], ['DECL']]
in rule  ['DECL']  with  }
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
in symbol DECL 		(in rule  ['DECL'] )
in producer
in match rule with  DECL : [['type', 'identifier', ';']]
in rule  ['type', 'identifier', ';']  with  }
TREE
FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL'], ['type', 'identifier', ';']]
in symbol type 		(in rule  ['type', 'identifier', ';'] )
is token
in match token } punctuation type
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST'], ['DECL']]
returned false  ['type', 'identifier', ';'] [['type', 'identifier', ';']]
2. unmatched DECL } } ['DECL']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT'], ['DECL_ST']]
returned false  ['DECL'] [['DECL', 'ST'], ['DECL']]
2. unmatched DECL_ST } } ['DECL_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST'], ['STATEMENT']]
returned false  ['DECL_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']]
2. unmatched STATEMENT } } ['STATEMENT']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['STATEMENT_ST']]
returned false  ['STATEMENT'] [['STATEMENT', ';', 'ST'], ['STATEMENT']]
2. unmatched STATEMENT_ST } } ['STATEMENT_ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN', 'ST'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
returned false  ['STATEMENT_ST'] [['STATEMENT_ST']]
2. unmatched ST } } ['ASSIGN', 'ST']
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST']]
returned false  ['ASSIGN', 'ST'] [['ASSIGN', 'ST'], ['ASSIGN']]
in rule  ['ASSIGN']  with  l
TREE
FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T ) E E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT STATEMENT ; ST STATEMENT ) STATEMENT_ST ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN']]
in symbol ASSIGN 		(in rule  ['ASSIGN'] )
in producer
in match rule with  ASSIGN : [['identifier', '=', 'EXPRESSION', ';']]
in rule  ['identifier', '=', 'EXPRESSION', ';']  with  l
TREE
FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T ) E E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';']]
in symbol identifier 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
is token
in match token l identifier identifier
matched
2. temp store = =
in symbol = 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else = =
matched
in symbol EXPRESSION 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
in producer
in match rule with  EXPRESSION : [['E']]
in rule  ['E']  with  5
TREE
ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T ) E E E ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
in symbol E 		(in rule  ['E'] )
in producer
in match rule with  E : [['T', "E'"], ['T']]
in rule  ['T', "E'"]  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
in symbol T 		(in rule  ['T', "E'"] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"]]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T', "E'"]
1. temp store ; ;
in symbol E' 		(in rule  ['T', "E'"] )
in producer
in match rule with  E' : [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['+', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' + T E' - T E' + T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['+', 'T', "E'"]]
in symbol + 		(in rule  ['+', 'T', "E'"] )
else ; +
5. unmatched + ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['+', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
in rule  ['-', 'T', "E'"]  with  ;
TREE
E' (+ T E' - T E' + T E' - T E' + T E' - T E' + T E' - T E' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number'], ['-', 'T', "E'"]]
in symbol - 		(in rule  ['-', 'T', "E'"] )
else ; -
5. unmatched - ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T', "E'"], ['F'], ['G'], ['number']]
returned false  ['-', 'T', "E'"] [['+', 'T', "E'"], ['-', 'T', "E'"]]
2. unmatched E' ; ; ['T', "E'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E']]
returned false  ['T', "E'"] [['T', "E'"], ['T']]
in rule  ['T']  with  5
TREE
E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T T E' T ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
in symbol T 		(in rule  ['T'] )
in producer
in match rule with  T : [['F', "T'"], ['F']]
in rule  ['F', "T'"]  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' F F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
in symbol F 		(in rule  ['F', "T'"] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"]]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F', "T'"]
1. temp store ; ;
in symbol T' 		(in rule  ['F', "T'"] )
in producer
in match rule with  T' : [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['*', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['*', 'F', "T'"]]
in symbol * 		(in rule  ['*', 'F', "T'"] )
else ; *
5. unmatched * ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['*', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
in rule  ['/', 'F', "T'"]  with  ;
TREE
T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number'], ['/', 'F', "T'"]]
in symbol / 		(in rule  ['/', 'F', "T'"] )
else ; /
5. unmatched / ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F', "T'"], ['G'], ['number']]
returned false  ['/', 'F', "T'"] [['*', 'F', "T'"], ['/', 'F', "T'"]]
2. unmatched T' ; ; ['F', "T'"]
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T']]
returned false  ['F', "T'"] [['F', "T'"], ['F']]
in rule  ['F']  with  5
TREE
T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' F F T' F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
in symbol F 		(in rule  ['F'] )
in producer
in match rule with  F : [['G', '^', 'F'], ['G']]
in rule  ['G', '^', 'F']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
in symbol G 		(in rule  ['G', '^', 'F'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G', '^', 'F'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G', '^', 'F']
1. temp store ; ;
in symbol ^ 		(in rule  ['G', '^', 'F'] )
else ; ^
5. unmatched ^ ;
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F']]
returned false  ['G', '^', 'F'] [['G', '^', 'F'], ['G']]
in rule  ['G']  with  5
TREE
F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
in symbol G 		(in rule  ['G'] )
in producer
in match rule with  G : [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['(', 'E', ')']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['(', 'E', ')']]
in symbol ( 		(in rule  ['(', 'E', ')'] )
else 5 (
5. unmatched ( 5
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['(', 'E', ')'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['identifier']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['identifier']]
in symbol identifier 		(in rule  ['identifier'] )
is token
in match token 5 number identifier
4. unmatched token
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G']]
returned false  ['identifier'] [['(', 'E', ')'], ['identifier'], ['number']]
in rule  ['number']  with  5
TREE
G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) 
STACK  ['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
in symbol number 		(in rule  ['number'] )
is token
in match token 5 number number
matched
2. temp store 5 ;
here we are ['number'] [['(', 'E', ')'], ['identifier'], ['number']] 2
1.SYMBOL in RULE G ['G']
1. temp store 5 ;
here we are ['G'] [['G', '^', 'F'], ['G']] 1
1.SYMBOL in RULE F ['F']
1. temp store 5 ;
here we are ['F'] [['F', "T'"], ['F']] 1
1.SYMBOL in RULE T ['T']
1. temp store 5 ;
here we are ['T'] [['T', "E'"], ['T']] 1
1.SYMBOL in RULE E ['E']
1. temp store 5 ;
here we are ['E'] [['E']] 0
1.SYMBOL in RULE EXPRESSION ['identifier', '=', 'EXPRESSION', ';']
1. temp store ; ;
in symbol ; 		(in rule  ['identifier', '=', 'EXPRESSION', ';'] )
else ; ;
matched
here we are ['identifier', '=', 'EXPRESSION', ';'] [['identifier', '=', 'EXPRESSION', ';']] 0
1.SYMBOL in RULE ASSIGN ['ASSIGN']
1. temp store l }
here we are ['ASSIGN'] [['ASSIGN', 'ST'], ['ASSIGN']] 1
1.SYMBOL in RULE ASSIGN_ST ['ASSIGN_ST']
1. temp store l }
here we are ['ASSIGN_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']] 3
1.SYMBOL in RULE STATEMENT ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']
1. temp store } }
in symbol } 		(in rule  ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] )
else } }
matched
here we are ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'] [['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}']] 0
1.SYMBOL in RULE FOR_LOOP ['FOR_LOOP']
1. temp store for eof
here we are ['FOR_LOOP'] [['FOR_LOOP', 'ST'], ['FOR_LOOP']] 1
1.SYMBOL in RULE FOR_LOOP_ST ['FOR_LOOP_ST']
1. temp store for eof
here we are ['FOR_LOOP_ST'] [['FOR_LOOP_ST'], ['IF_COND_ST'], ['DEFN_ST'], ['ASSIGN_ST'], ['DECL_ST']] 0
1.SYMBOL in RULE STATEMENT ['STATEMENT', 'eof']
1. temp store eof eof
in symbol eof 		(in rule  ['STATEMENT', 'eof'] )
else eof eof
done!
here we are ['STATEMENT', 'eof'] [['STATEMENT', 'eof']] 0
VALID for eof
TREE
PROG (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) ; identifier = EXPRESSION ; ) COND (EXPRESSION1 (EXPRESSION (E (T (F (G (( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ( E ) identifier ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) EXPRESSION ) relational_operator EXPRESSION2 (EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) EXPRESSION ) ; EXPRESSION1 relational_operator EXPRESSION2 ; ) INCREMENT (I_ASSIGN (identifier = EXPRESSION (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' ) T T E' T ) E ) identifier = EXPRESSION ) I_ASSIGN ) ) { STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN (E (T (F (G (( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ( E ) identifier number ) ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G G ^ F G ) T' (* F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' * F T' / F T' ) F F T' F F T' F F T' F F T' F F T' F F T' F F T' F ) E' (+ T E' - T E' + T E' - T E' + T E' - T E' + T E' - T E' ) T T E' T T E' T T E' T ) E E E ) COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT STATEMENT ; ST STATEMENT ) STATEMENT_ST ) FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN ) IF_COND_ST DEFN_ST ASSIGN_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST ) } for ( ASSIGN COND INCREMENT ) { STATEMENT } ) ST (STATEMENT_ST (STATEMENT (FOR_LOOP_ST (FOR_LOOP (for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; for ( ASSIGN COND INCREMENT ) { STATEMENT } for ( ASSIGN COND INCREMENT ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } if ( COND ) { STATEMENT ; } OP_ELSE if ( COND ) { STATEMENT } type identifier = EXPRESSION ; type identifier = EXPRESSION ; identifier = EXPRESSION ; identifier = EXPRESSION ; type identifier ; type identifier ; ) ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL FOR_LOOP ST FOR_LOOP IF_COND ST IF_COND DEFN ST DEFN ASSIGN ST ASSIGN DECL ST DECL ) IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST FOR_LOOP_ST IF_COND_ST DEFN_ST ASSIGN_ST DECL_ST ) ; ST STATEMENT ) ) FOR_LOOP ) ) eof ) 
STACK ----
['PROG', ['STATEMENT', 'eof'], ['FOR_LOOP_ST'], ['FOR_LOOP'], ['for', '(', 'ASSIGN', 'COND', 'INCREMENT', ')', '{', 'STATEMENT', '}'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number'], ['EXPRESSION1', 'relational_operator', 'EXPRESSION2', ';'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['identifier'], ['EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['I_ASSIGN'], ['identifier', '=', 'EXPRESSION'], ['E'], ['T'], ['F'], ['G'], ['number'], ['ASSIGN_ST'], ['ASSIGN'], ['identifier', '=', 'EXPRESSION', ';'], ['E'], ['T'], ['F'], ['G'], ['number']]
